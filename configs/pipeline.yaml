# =============================================================================
# Schweiß-KI Pipeline Konfiguration
# AP2.1 - Optimierter Datenfluss: STEP → Segmentierte Punktwolke
# =============================================================================
# Phasen:
#   Phase 1 (KW 06-08): CAD-Konvertierung + WeldVolumeModel         ← abgeschlossen
#   Phase 2 (KW 09-11): Preprocessing                               ← aktiv
#   Phase 3 (KW 10-15): Segmentierung (RANSAC)                      ← noch nicht aktiv
#   Phase 4 (KW 13-14): Segmentierung (PointNet) - optional         ← noch nicht aktiv
# =============================================================================

# Eingabeverzeichnis mit STEP-Dateien
input_dir: data/synthetic/test_step_files

# Output-Konfiguration
output:
  output_dir: data/processed/test_files
  save_model: true
  save_intermediate: false   # Zwischenschritte speichern (für Debugging)


# ── Stage 1: CAD-Konvertierung ────────────────────────────────────────────────
# STEP → Punktwolke via Michel's API
# Status: aktiv (Phase 1)
# -----------------------------------------------------------------------------
cad_conversion:
  enabled: true
  point_density: null        # null = API-Standard


# ── Stage 2: Preprocessing ───────────────────────────────────────────────────
# Konfigurierbare Chain zur Aufbereitung von Punktwolken.
# Status: aktiv (Phase 2)
#
# Aufbau:
#   enabled:                   Globaler Ein-/Ausschalter für die gesamte Stage
#   source_type_overrides:     Überschreiben einzelne Step-Parameter je nach
#                              WeldVolumeModel.source_type ("ideal"/"real"/"synthetic")
#   steps:                     Globale Defaults – Reihenfolge = Ausführungsreihenfolge
#
# Alle Längenwerte in mm.
# Parameter werden mit realen Scandaten von Heidenbluth validiert und angepasst.
# -----------------------------------------------------------------------------
preprocessing:
  enabled: false             # ← auf true setzen wenn Pipeline-Integration fertig

  # ── Source-Type-Overrides ──────────────────────────────────────────────────
  # WeldVolumeModel.source_type bestimmt automatisch welcher Override aktiv ist.
  source_type_overrides:

    ideal:
      # CAD-Punktwolken (von Michel's API) sind sauber – Outlier-Filter nicht nötig
      statistical_outlier_filter:
        enabled: false
      radius_outlier_filter:
        enabled: false
      # Voxel-Downsampling trotzdem für konsistente Dichte, aber feiner
      voxel_grid_downsampler:
        voxel_size: 0.3

    synthetic:
      # Synthetisches Rauschen ist kontrolliert – weniger aggressives Filtering
      statistical_outlier_filter:
        std_ratio: 3.0

    real:
      # Reale Scandaten: alle Filter aktiv
      # Parameter werden nach Eingang der Heidenbluth-Scans validiert
      statistical_outlier_filter:
        enabled: true
      radius_outlier_filter:
        enabled: true

  # ── Steps (globale Defaults) ───────────────────────────────────────────────
  # Reihenfolge der Schlüssel = Ausführungsreihenfolge der Pipeline.

  steps:

    # 1. Statistischer Ausreißerfilter
    #    Entfernt Punkte deren mittlere kNN-Distanz weit vom Durchschnitt abweicht.
    #    Zuerst ausführen: grobe Fehler vor feinerer Verarbeitung entfernen.
    statistical_outlier_filter:
      enabled: true
      nb_neighbors: 20    # Anzahl Nachbarn für Distanzberechnung
      std_ratio: 2.0      # Schwellwert in Standardabweichungen (kleiner = aggressiver)

    # 2. Radius-Ausreißerfilter
    #    Entfernt isolierte Einzelpunkte (potenzielle Spritzer-Kandidaten).
    #    Deaktiviert by default – erst sinnvoll mit realen Scandaten.
    radius_outlier_filter:
      enabled: false
      nb_points: 16       # Mindestanzahl Nachbarn im Radius
      radius: 1.5         # Suchradius in mm

    # 3. Voxel-Grid-Downsampling
    #    Gleichmäßige Punktdichte über die gesamte Punktwolke.
    #    voxel_size abhängig von Scanner-Auflösung – nach Erhalt der Heidenbluth-Scans anpassen.
    voxel_grid_downsampler:
      enabled: true
      voxel_size: 0.5     # Voxelgröße in mm (Faustregel: 2-3× mittlerer Punktabstand)

    # 4. Normalenschätzung
    #    Berechnet Oberflächennormalen – Voraussetzung für RANSAC-Segmentierung (Phase 4).
    normal_estimator:
      enabled: true
      radius: 2.0         # Suchradius für Nachbarpunkte in mm
      max_nn: 30          # Maximale Nachbarn im Suchradius
      orient_mode: consistent   # "consistent" oder "camera"
      # camera_location: [0.0, 0.0, 100.0]  # Nur bei orientation: camera


# ── Stage 3: Segmentierung ───────────────────────────────────────────────────
# Klassifikation der Punkte in semantische Regionen
# Status: noch nicht aktiv (Phase 4)
#
# Labels:
#   0 = background       (Umgebung, außerhalb relevantem Bereich)
#   1 = flank_a          (Flanke A – eine Seite der V-Naht)
#   2 = flank_b          (Flanke B – andere Seite der V-Naht)
#   3 = weld_zone        (Nahtbereich: Wurzel, Gap – Region zwischen den Flanken)
# Hinweis: Flanken separat, da AP2.2 jede Seite einzeln mit CAD abgleicht
# -----------------------------------------------------------------------------
segmentation:
  enabled: false
  method: ransac             # ransac | pointnet | hybrid

  # RANSAC – geometrische Segmentierung
  ransac_threshold: 0.25     # mm – entspricht Toleranzanforderung ±0.25mm
  ransac_max_iterations: 1000
  dbscan_eps: 0.5            # mm – Nachbarschaftsradius für Cluster
  dbscan_min_points: 10      # Mindestpunkte pro Cluster

  # PointNet – ML-basierte Segmentierung (Phase 4, optional)
  # pointnet_model: models/pointnet_weights.pth
  # pointnet_confidence_threshold: 0.8


# ── Evaluation ───────────────────────────────────────────────────────────────
# Metriken die nach jedem Lauf berechnet werden
# Status: noch nicht aktiv
# -----------------------------------------------------------------------------
# evaluation:
#   enabled: false
#   metrics:
#     - point_retention_rate   # Preprocessing: wie viele Punkte bleiben
#     - processing_time        # Laufzeit pro Stage
#     - iou_per_class          # Segmentierung: Intersection over Union
#     - overall_accuracy       # Segmentierung: Gesamtgenauigkeit
#   output_file: results/eval_{timestamp}.json